use crate::BufferSnapshot;
use anyhow::Result;
use std::ops::Range;

pub trait EditBehaviorImplementation: Send + Sync {
    fn boxed_should_auto_edit(
        &self,
        buffer: &BufferSnapshot,
        edited_ranges: &[Range<usize>],
    ) -> Option<Box<dyn std::any::Any + Send>>;
    fn boxed_auto_edit(
        &self,
        buffer: BufferSnapshot,
        ranges: &[Range<usize>],
        state: Box<dyn std::any::Any + Send>,
    ) -> Result<Vec<(Range<usize>, String)>>;
}

impl<T> EditBehaviorImplementation for T
where
    T: EditBehaviorProvider,
{
    fn boxed_should_auto_edit(
        &self,
        buffer: &BufferSnapshot,
        edited_ranges: &[Range<usize>],
    ) -> Option<Box<dyn std::any::Any + Send>> {
        let Some(result) = self.should_auto_edit(buffer, edited_ranges) else {
            return None;
        };
        Some(Box::new(result))
    }

    fn boxed_auto_edit(
        &self,
        buffer: BufferSnapshot,
        ranges: &[Range<usize>],
        state: Box<dyn std::any::Any + Send>,
    ) -> Result<Vec<(Range<usize>, String)>> {
        let state = *state
            .downcast::<T::AutoEditState>()
            .expect("Invalid state type");
        self.auto_edit(buffer, ranges, state)
    }
}

pub trait EditBehaviorProvider: Send + Sync {
    /// Temporary state generated by `should_auto_edit`
    /// and passed to `auto_edit`. Can be used to store
    /// data related to the auto-editing process to avoid
    /// redundant computations, or be `()` if no state is
    /// needed.
    type AutoEditState: std::any::Any + Send;

    /// This method is called before `auto_edit` is called.
    /// It should return `Some(state)` if auto-editing should be performed,
    /// and `None` if it should not.
    fn should_auto_edit(
        &self,
        buffer: &BufferSnapshot,
        edited_ranges: &[Range<usize>],
    ) -> Option<Self::AutoEditState>;

    /// This method is called after `should_auto_edit` returns `Some(state)`.
    /// It is passed the buffer snapshot *after* edits have been applied and a Vec of
    /// the ranges describing the edits that were applied.
    ///
    /// It should return a vector of ranges and strings representing the edits
    /// to be applied to the buffer.
    fn auto_edit(
        &self,
        buffer: BufferSnapshot,
        ranges: &[Range<usize>],
        state: Self::AutoEditState,
    ) -> Result<Vec<(Range<usize>, String)>>;
}
